## 详解KMP模式匹配算法

[TOC]

### 0、Intro

什么是字符串的模式匹配？

给定一个 **haystack** 字符串和一个 **needle** 字符串，在 **haystack** 字符串中找出 **needle** 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。

示例 1：输入: haystack = "hello", needle = "ll" 输出：2

示例 2：输入: haystack = "aaaaa", needle = "bba" 输出：-1

说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

### 1、朴素模式匹配

关于[朴素模式匹配]([图解KMP算法，带你彻底吃透KMP-CSDN博客](https://blog.csdn.net/qq_43869106/article/details/128753527))，这位博主已经说的非常明晰。朴素模式匹配时，对主串进行外循环，对子串进行内循环。首先判断主串首字符与子串首字符是否相同，若相同则继续向后比较，若子串持续移动到尾部下一位，说明比较完成，返回主串首字符下标即可，若子串移动到某一位置匹配不一致，此时需要跳出内循环，子串重新指向首字符，主串指向首字符后一个字符，重新开始匹配。

对于一个长度位为n的主串，为了在其中找到一个长度为m（n >= m）的子串，时间复杂度最大会达到$O((n-m+1)*m)$。

```c++
// 字符串朴素模式匹配算法
// leetcode验证通过
class Solution{
  int strStr(string haystack, string needle){
      int m = needle.size();
      int n = haystack.size();
      if(m == 0) return 0;
      int j = 0;
      for(int i = 0; i < n - m + 1; ++i){
          while(i < n && j < m){
              if(haystack[i] == needle[j]){
                  ++i;
                  ++j;
              }
              else{
                  i = i - j;
                  j = 0;
                  break;
              }
          }
          if(j > m) return i - j;
      }
      
     return -1;
  }
};
```

> 此处参考[《大话数据结构》]([zh.z-lib.gs](https://zh.z-lib.gs/book/21866019/61284b/大话数据结构溢彩加强版.html))5.6 朴素的模式匹配算法

### 2、KMP模式匹配

不满足于使用朴素模式匹配方法，$D.E.Knuth$、$J.H.Morris$和$V.R.Pratt$三人开发出了新的模式匹配方法，新方法以三人名字首字母命名，即为**KMP模式匹配**。

#### 1.KMP算法详细说明

##### KMP算法到底要做什么呢？

无论是朴素模式匹配还是KMP模式匹配，都是使用双指针法。在匹配比较的过程中，如果在某一位置主串和子串不相同，但是在主串该字符前的**连续p个元素字符**与子串中**前p个字符**可能是相同的，此时我们希望主串指针不动，子串指针移动到**前p个字符之后（也有可能是子串首字符位置）**，即通过一种办法记住一部分之前已经匹配的子串字符，避免朴素匹配每次都要从头开始的情况。

KMP算法提出的记住一部分已经匹配过的字符的方法是针对子串使用**前缀表**（概念可以在[第三节](#section-1)查阅）。以子串$T="aabaaf"$为例，前缀表的生成过程如下：

+ 对于小子串$s[0] = 'a'$，其前缀后缀都没有，故最大相等前后缀的长度为0，初始化时就可以置为0；

+ 对于小子串$'aa'$，其前缀后缀都为$'a'$，故最大相等前后缀的长度为1；

+ 对于小子串$'aab'$，其前缀为$'a'、'aa'$，后缀为$'b'、'ab'$，故最大相等前后缀的长度为0；

+ 对于小子串$'aaba'$，其前缀为$'a'、'aa'、'aab'$，后缀为$'a'、'ba'、'aba'$，故最大相等前后缀的长度为1；

+ 对于小子串$'aabaa'$，其前缀为$'a'、'aa'、'aab'、'aaba'$，后缀为$'a'、'aa'、'baa'、'abaa'$，故最大相等前后缀的长度为2；

+ 对于小子串$'aabaaf'$，其前缀为$'a'、'aa'、'aab'、'aaba'、'aabaa'$，后缀为$'f'、'af'、'aaf'、'baaf'、'abaaf'$，故最大相等前后缀的长度为0。

由此可得子串前缀表为$next[\space] = \{0,1,0,1,2,0\}$，这里使用的**next数组**即为前缀表。

##### 为什么使用前缀表呢？

以主串S = "aabaa<font color='red'>b</font>aaf"和子串T = "aabaa<font color='red'>f</font>"为例，首先以我自己的话来总结前缀表的作用：当遇到主串中"<font color='red'>b</font>"与子串字符"<font color='red'>f</font>"不相同时，主串"<font color='red'>b</font>"与子串"<font color='red'>f</font>"前的“aa“、与T字符串开头的”aa“是相同的，此时不需要对子串T从头重新与主串"<font color='red'>b</font>"进行比较，直接从T字符串开头的”aa“后的字符开始即可。

”<font color='red'>f</font>“字符的前一位"a"在前缀表中的对应元素为”2“，代表在字符”<font color='red'>f</font>“前的小子串中，开头2个字符与”<font color='red'>f</font>“前的两个字符是相同的，下次比较直接从T中第3个字符开始即可，由于字符串的下标是从0开始，此处的"2"既对应了最大相等前后缀的长度，又对应了重新匹配开始的下标。

![KMP精讲1](./../../../../Typora/image/KMP%E7%B2%BE%E8%AE%B21.gif)

##### 如何通过编程求出子串的前缀表呢？

首先明确，在求子串的前缀表时，与主串没有任何关系。

逻辑上编程实现思路如下：

令$j = 0$，其中$j$指向子串中小子串前缀的末尾，同时$j+1$也表示小子串最大相等前后缀的长度（前缀长度=后缀长度）；令$i = 1$（next[0]初始化时已经被置为0了），其中$i$指向子串中小子串后缀的末尾。从头开始分析，$j$要始终小于$i$。当$T[i] == T[j]$时，说明$i$所对应的后缀连续小子串与$j$所对应的前缀连续小子串是相同的，此时$i$字符之前的小子串的最大相等前后缀长度为$j+1$；当$T[i]!=T[j]$时，此时$i$之前的字符与$j$之前的字符已经完成过匹配，只需要通过回退到$j$的前一位字符对应的前缀表值（数字）连续回退到$<j = 0 || T[i] == T[j]>$为止，此时$i$字符之前的小子串的最大相等前后缀长度为$j+1$或0。

实际上，对子串求其前缀表相当于在字串内完成了一次KMP模式匹配，$j$指向的是子串，$i$指向的是主串。

下图使用了前缀表个元素-1形式构造了next数组，参考[KMP算法中的重要概念](#section-1)。

![KMP精讲3](./../../../../Typora/image/KMP%E7%B2%BE%E8%AE%B23.gif)

##### 知道了子串前缀表如何运用到解决子串与主串匹配的问题中呢？

与编程求子串的前缀表过程类似，若子串与主串元素相同，则持续后移；若子串与主串元素不同，指向子串的指针通过next数组进行回退，指向主串的指针不动。具体实现参考[KMP算法代码实现](#section-2)。

![KMP精讲2](./../../../../Typora/image/KMP%E7%B2%BE%E8%AE%B22.gif)

#### 2.KMP算法复杂度分析

**时间复杂度分析：**

KMP算法复杂度要考虑到求前缀表的复杂度和匹配的复杂度。

对于一个长度位为n的主串，为了在其中找到一个长度为m（n >= m）的子串，最坏情况下主串要遍历到结束，子串移动到最后发现要一格一格回退，此时时间复杂度最大会达到$O(m+n)$。

<a id="section-1"></a>

#### 3.KMP算法中的重要概念

**前缀**：是指**不包含最后一个字符**的所有**以第一个字符开头**的连续子串

**后缀：**是指**不包含第一个字符**的所有**以最后一个字符结尾**的连续子串

**前缀表**：用来回退的数组，它记录了子串与主串不匹配的时候，子串应该从哪里开始重新匹配

**next数组**：一般就是前缀表，或是将前缀表每个元素-1，或是将前缀表元素整体右移且0下标所对位置赋为-1

<a id="section-2"></a>

#### 4.KMP算法代码实现

```c++
// 字符串KMP模式匹配算法
// leetcode28验证通过
#include <iostream>

class Solution{
  void getNext(int *next, string &s){
        int j = 0;                                   // j指向小子串前缀表的末尾，同时也是最大相等前后缀的长度
        next[0] = 0;                                 // 子串的第一位最大相等前后缀始终为0
        for(int i = 1; i < s.size(); ++i){           // i指向小子串后缀表的末尾
            // 
            while(j > 0 && s[i] != s[j]){
                j = next[j - 1];
            }

            if(s[i] == s[j]){
                ++j;
            }
            
            next[i] = j;
        }
    }

    // KMP模式匹配
    int strstr(string haystack, string needle){
        if(needle.size() == 0) {
            return 0;
        }

        int *next = new int[needle.size()];
        getNext(&next[0], needle);
        int j = 0;
        int i;

        for(i = 0; i < haystack.size(); ++i){
            while(j > 0 && haystack[i] != needle[j]){
                j = next[j - 1];
            }

            if(haystack[i] == needle[j]){
                ++j;
            }

            if(j >= needle.size()) return (i - j + 1);
        }

        return -1;
    }
    
};
```

> 此处参考[《大话数据结构》]([zh.z-lib.gs](https://zh.z-lib.gs/book/21866019/61284b/大话数据结构溢彩加强版.html))5.7 KMP模式匹配算法
>
> GIF图像来自[代码随想录 ](https://programmercarl.com/0028.实现strStr.html#思路)

### 3、总结

KMP算法通过next数组（前缀表）记住了子串的元素信息，在与主串匹配遇到字符不相同时，子串可通过next数组回退到指定位置而不是直接从头开始匹配，有效降低了朴素匹配带来的复杂度。
